/*
 * ObjectWriter.java
 *
 * OraDoclet 0.1
 * Oracle Schema Documentation Generator
 * Copyright (C) 2004 Vladimir Katchourovski <oradoclet@narod.ru>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package net.oradoclet;

import java.io.*;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;

/**
 * Generates the Object Information Page.
 * Such a page lists the object's attributes and the child objects.
 *
 * The descendent class should override the generateObjectAttributes() method
 * to provide the object-specifical output.
 */
public class ObjectWriter extends HtmlWriter {
    private Connection     dbconnection = null;
    private TreeMap        objectTree   = null;
    private DatabaseObject dbobject     = null;
    private String         appTitle     = null;
    private String         copyright    = null;

    // TODO make it static to spare the memory
    protected ObjectWriterSection[] sections = null;

    /**
     * Standard constructor
     *
     * @param dbconnection
     * @param objectTree
     * @param dbobject
     * @throws IOException
     */
    public ObjectWriter(Connection  dbconnection, TreeMap objectTree, DatabaseObject dbobject, ObjectWriterSection[] newSections) throws IOException {
        super(OraDoclet.getConfiguration(), OraDoclet.getConfiguration().destdirname,
            dbobject.getObjectType().toLowerCase() + "-" + dbobject.getObjectName().toLowerCase().replace('\\', '_').replace('/', '_').replace(':', '_') +  ".html" ,
            OraDoclet.getConfiguration().encoding);
        this.dbconnection = dbconnection;
        this.objectTree   = objectTree;
        this.dbobject     = dbobject;
        this.appTitle     = OraDoclet.getConfiguration().applicationTitle;
        this.copyright    = OraDoclet.getConfiguration().copyrightLabel;
        this.sections     = (null!=newSections) ? newSections : getSections();
    }

    /**
     * Generate a page for each object
     */
    public void generate()  {
        if(null != this.dbobject) {
            generateObjectFile(this.dbconnection, this.objectTree, this.dbobject, this.appTitle, this.copyright);
        }
    }

    /**
     * Generate the table file contents.
     */
    protected void generateObjectFile(Connection dbconnection, TreeMap objectTree, DatabaseObject dbobject, String appTitle, String copyright) {
        try {
            html();
            head();
            link("rel='stylesheet' type='text/css' href='style.css'");
            headEnd();
            body(true);

            // Each object's page includes top and bottom bars, generated by DocFilesetWriter class
            DocFilesetWriter docFilesetWriter = new DocFilesetWriter(dbconnection, objectTree);
            docFilesetWriter.generateTopBar(this, appTitle);
            generateObjectAttributes(dbconnection, objectTree, dbobject);
            docFilesetWriter.generateBottomBar(this, copyright);

            bodyEnd();
            htmlEnd();
            docFilesetWriter = null;
        } catch(IOException iox) {
            iox.printStackTrace();
        }
    }

    /**
     * The method returns the array of sections.
     * Should be overriden by the descendant.
     */
    protected static ObjectWriterSection[] getSections() {
        ObjectWriterSection[] s =
            {new ObjectWriterSection("Description",       "Description",      false, false),
             new ObjectWriterSection("Columns",           "Column",           true,  false),
             new ObjectWriterSection("Primary key",       "Primary key",      true,  false),
             new ObjectWriterSection("Check constraints", "Check constraint", true,  false),
             new ObjectWriterSection("Foreign keys",      "Foreign key",      true,  false),
             new ObjectWriterSection("Unique keys",       "Unique key",       true,  false),
             new ObjectWriterSection("Indexes",           "Index",            true,  false),
             new ObjectWriterSection("Options",           "Option",           true,  true),
             new ObjectWriterSection("Referenced by",     "Referenced by",    true,  false),
             new ObjectWriterSection("Triggers",          "Trigger",          true,  false)
            };
        return s;
    }

    /**
     * Returns the section name by its number
     *
     * @param i The section number
     * @return The section name when the section with the given number exists, null otherwise
     */
    protected ObjectWriterSection getSection(int i) {
        if(i < sections.length) {
            return sections[i];
        } else {
            return null;
        }
    }

    /**
     * Returns the total number of the sections,
     * presented on the description page for this
     * database object type.
     *
     * @return The section name when the section with the given number exists, null otherwise
     */
    protected int getSectionCount() {
        return sections.length;
    }

    /**
     * Generates the page describing the attributes and child objects of the given object.
     * This method is object-specific and should be implemented in the descendent classes
     * of the <code>ObjectWriter</code>
     *
     * @param dbconnection
     * @param objectTree
     * @param dbobject
     */
    protected void generateObjectAttributes(Connection dbconnection, TreeMap objectTree, DatabaseObject dbobject) {
        write("<div id='object_attributes'>");
        for (int i = 0; i < getSectionCount(); i++) {
            anchor("#"
                + dbobject.getObjectType().substring(0, 1).toLowerCase()
                + "-"
                + getSection(i).name.toLowerCase(),
                getSection(i).name);
            space();
            space();
        }
        write("</div>");
        hr();
        h2();
        println(dbobject.getObjectName().toUpperCase());
        h2End();
        p();
        // generate documentation for the object.
        // information about all attributes is printed here
        for (int i = 0; i < getSectionCount(); i++) {
            try {
                listAttributes(dbobject, getSection(i).attributeName, getSection(i).name, getSection(i).tabular, getSection(i).transposed);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * Draws a table that lists all the child objects and object attributes
     *
     * @param dbobject
     */
    protected void listAttributes(DatabaseObject dbobject, String attributeName, String sectionName
        , boolean tabular, boolean transpose) throws SQLException {
        DatabaseAttribute attr = null;
        Vector  names      = new Vector();
        Vector  attributes = new Vector();
        TreeMap attrTable  = new TreeMap();
        String  attrName   = null;
        String  attrValue  = null;
        String  attrAncor  = "";

        for(int k=0; k<dbobject.getAttributeMatrix().size(); k++) {
            // Fetch a matrix line
            Vector attrMatrixLine  = (Vector) dbobject.getAttributeMatrix().elementAt(k);
            Vector attributeList   = attrMatrixLine;
            // Go on if the line has elements
            if(null!=attrMatrixLine && attrMatrixLine.size() > 0) {
                // If the 1st attribute is of given name, process this line
                // For child objects the value of the 1st objects represents an object key
                attrName           = ((DatabaseAttribute) attrMatrixLine.elementAt(0)).getName();
                String   childKey  = ((DatabaseAttribute) attrMatrixLine.elementAt(0)).getValue();
                if(attrName.equalsIgnoreCase(attributeName)) {
                    // Check whether this is a child object
                    DatabaseObject childObject = (DatabaseObject) this.objectTree.get(childKey);

                    if(null!=childObject && null!=childObject.getAttributeMatrix()) {
                        if(childObject.getAttributeMatrix().size() > 0) {
                            //attributeList = new Vector((Vector) childObject.getAttributeMatrix().elementAt(0));
                            attributeList = (Vector) childObject.getAttributeMatrix().elementAt(0);
                        } else {
                            attributeList = new Vector();
                        }

                        // Add the child object name to the attribute list
                        attributeList.add(0, new DatabaseAttribute(attributeName, childObject.getObjectName(), true));
                        // Prepare an ancor for the name, if the object is linkable
                        if(null!=childObject.getLink()) {
                            attrAncor = childObject.getLink();
                            attrAncor = "<a name=\"" + attrAncor.substring(attrAncor.indexOf('#') + 1) + "\"></a>";
                        } else {
                            attrAncor = "";
                        }
                    }
                    // Add the member columns for objects that expect such ones
                    if(attributeName.equalsIgnoreCase("Index")
                        || attributeName.equalsIgnoreCase("Primary key")
                        || attributeName.equalsIgnoreCase("Foreign key")
                        || attributeName.equalsIgnoreCase("Unique key")) {
                        String ownerName = ((DatabaseAttribute) attributeList.elementAt(0)).getValue();
                        String ownerType = attributeName.equalsIgnoreCase("Index") ? "INDEX" : "CONSTRAINT";
                        DatabaseAttribute columnList = new DatabaseAttribute("Columns", getMemberColumns(ownerType, ownerName), true);
                        attributeList.add(columnList);
                    }

                    String name = null;
                    // Present the attribute in a table form or as a string, if it is a single entry
                    for(int i=0; i<attributeList.size();i++) {
                        attr = (DatabaseAttribute) attributeList.elementAt(i);

                        if(!attr.isVisible()) continue;

                        attrName = attr.getName();
                        // Add to the attributes (new table column)
                        if(null!=attrName && !attributes.contains(attrName)) {
                            attributes.add(attrName);
                        }
                        // Add to the names (new table line)
                        if(attrName.equalsIgnoreCase(attributeName)) {
                            // If this identifier is not hosted on this page, it gets a link to its original page
                            if(0==attrAncor.length() &&  null!=attr.getDbobject()) {
                                name = "<a href=\"" + attr.getDbobject().getLink()
                                    + "\">" + attr.getDbobject().getObjectName() + "</a>";
                            } else {
                            //  Otherwise it gets an ancor
                                name = attr.getValue().toUpperCase() + attrAncor;
                            }

                            // In case of multiple entries enumerate them:
                            if(names.contains(name)) {
                                int n = 1;
                                do {
                                    n++;
                                } while(names.contains(name + "[" + n + "]"));
                                name = name + "[" + n + "]";
                            }

                            if(null!=name && !names.contains(name)) {
                                names.add(name);
                            }
                        }
                        // Check whether the attribute is a DatabaseObject(can be provided with a hyperlink)
                        if(null!=attr.getDbobject() && null!=attr.getDbobject().getLink()) {
                            attrValue = "<a href=\"" + attr.getDbobject().getLink()
                                + "\">" + attr.getDbobject().getObjectName() + "</a>";

                        } else {
                            attrValue = (null==attr.getValue() || 0==attr.getValue().length()) ? NBSP : attr.getValue();

                            if(attr.isPreformatted()) {
                                attrValue = "<pre><ol class='code'>"
                                        + attrValue
                                        + "</ol></pre>";
                            }
                        }
                        // Add the value, for non-tabular(single-line) attributes only if they are not empty
                        if(null!=name && null!=attrValue && (!(!tabular && attrValue.equalsIgnoreCase(NBSP)))) {
                            attrTable.put(name.toLowerCase() + "." + attrName.toLowerCase(), attrValue);
                        }
                        attr = null;
                    }
                }
            }
        }
// DEBUG
/*
//if(dbobject.getObjectName().equalsIgnoreCase("TERMS_BUCHUNG")) {
    System.out.println();
    System.out.println("sectionName=" + sectionName);
    System.out.println(dbobject);
    System.out.println("attrTable=" + attrTable);
//}
*/
// DEBUG
        if(attrTable.size() > 0) {

            String ancor =
                    dbobject.getObjectType().substring(0, 1).toLowerCase() + "-"
                            + sectionName.toLowerCase();
            aName(ancor);
            p();
            h3();
            println(sectionName);
            h3End();

            // If there is only one line, no table is build
            if(!tabular) {
                println(attrValue);
            } else {

                if(transpose) {
                    Vector tmp = names;
                    names = attributes;
                    attributes = tmp;
                    attributes.add(0, names.elementAt(0));
                    names.remove(0);
                }

                // Draw a table
                table(1,"100%");
                // Table header
                trClass("header");
                tdAlign("center");
                bold();
                String name = (String) attributes.elementAt(0);
                println(getInitCapString(name));
                boldEnd();
                tdEnd();
                for(int j=0;j<attributes.size();j++) {
                    if(!((String) attributes.elementAt(j)).equalsIgnoreCase(attributeName)) {
                        tdAlign("center");
                        bold();
                        println(getInitCapString((String) attributes.elementAt(j)));
                        boldEnd();
                        tdEnd();
                    }
                }
                trEnd();

                if(sectionName.equals("Package Body Source")){
                    tr();
                    tdAlignVAlign("left","top");

                    print("<pre><ol class='code'>");

                    String query = "SELECT uo.object_name                                    \"Package\", "
                            + "  us.text   \"Package Body Code\" "
                            //  + "  us.line||LPAD(':',5 - LENGTH(us.line))||to_clob(us.text)   \"Package Body Code\" "
                            + "  FROM all_source     us, "
                            + "       all_objects    uo  "
                            + " WHERE us.name = uo.object_name "
                            + "   AND uo.object_type = 'PACKAGE BODY' "
                            + "   AND uo.object_type = us.type "
                            + "   AND us.owner = '" + OraDoclet.CURRENT_SCHEMA + "'"
                            + "   AND uo.owner = '" + OraDoclet.CURRENT_SCHEMA + "'"
                            + "   AND uo.object_name = '" + dbobject.getObjectName() + "'"
                            + " ORDER BY uo.object_name, line ";
                    Statement stmt = dbconnection.createStatement();
                    ResultSet rs = stmt.executeQuery(query);
                    while(rs.next()){
                        print("<li class='multiline'>"
                                + rs.getString(2).replaceAll("&","&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;")
                                + "</li>");
                    }
                    rs.close();
                    stmt.close();
                    print("</ol></pre>");
                    flush();
                    tdEnd();
                    trEnd();
                } else if (sectionName.equals("Procedure Source")) {
                    tr();
                    tdAlignVAlign("left","top");

                    print("<pre><ol class='code'>");

                    String query = "SELECT uo.object_name                                    \"Procedure\", "
                            + "       us.text   \"Code\" "
                            //+ "       us.line||LPAD(':',5 - LENGTH(us.line))||to_clob(us.text)   \"Code\" "
                            + "  FROM all_source     us, "
                            + "       all_objects    uo  "
                            + " WHERE us.name = uo.object_name "
                            + "   AND uo.object_type = 'PROCEDURE' "
                            + "   AND uo.object_type = us.type "
                            + "   AND us.owner = '" + OraDoclet.CURRENT_SCHEMA + "'"
                            + "   AND uo.owner = '" + OraDoclet.CURRENT_SCHEMA + "'"
                            + "   AND uo.object_name = '" + dbobject.getObjectName() + "'"
                            + " ORDER BY uo.object_name, line ";

                    Statement stmt = dbconnection.createStatement();
                    ResultSet rs = stmt.executeQuery(query);
                    while(rs.next()){
                        print("<li class='multiline'>"
                                + rs.getString(2).replaceAll("&","&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;")
                                + "</li>");
                    }
                    rs.close();
                    stmt.close();
                    print("</ol></pre>");
                    flush();
                    tdEnd();
                    trEnd();
                } else {
                    // Table rows, one per child object
                    for(int i=0;i<names.size();i++){
                        tr();
                        tdAlignVAlign("left","top");

                        String displayedName = (String)names.elementAt(i);
                        // In case of the single column the value is displayed instead of the name (e.g. source code)
                        if(1==attributes.size()) {
                            displayedName = (String) attrTable.get(((String)names.elementAt(i)).toLowerCase() + "." + ((String)attributes.elementAt(0)).toLowerCase());
                        }
                        // Truncate the trailing enumeration index
                        if(displayedName.indexOf('[') > 0) {
                            displayedName = displayedName.substring(0, displayedName.lastIndexOf('['));
                        }

                        println(displayedName);
                        tdEnd();

                        // Table columns with attribute values
                        for(int j=1;j<attributes.size();j++) {
                            td();
                            if(transpose) {
                                attrValue = (String) attrTable.get(((String)attributes.elementAt(j)).toLowerCase() + "." + ((String)names.elementAt(i)).toLowerCase());
                            } else {
                                attrValue = (String) attrTable.get(((String)names.elementAt(i)).toLowerCase() + "." + ((String)attributes.elementAt(j)).toLowerCase());
                            }

                            println(attrValue);
                            flush();
                            tdEnd();
                        }

                        trEnd();
                    }
                }

                tableEnd();
                br();
            }
        }
    }


    /**
     * Returns the string containing comma-separated names of the columns
     * which are members of the given owner-object like index or constraint.
     * The names are provided with links and come in the respective order
     * as they appear in the index / constraint.
     *
     * @param ownerName
     * @param ownerType
     * @return
     */
    protected String getMemberColumns(String ownerType, String ownerName) {
        String  memberColumnsString = null;
        DatabaseObject dbobject     = null;
        TreeMap  memberColumns      = new TreeMap();

        Iterator it = this.objectTree.values().iterator();
        while(it.hasNext()) {
            dbobject = (DatabaseObject) it.next();
            if(dbobject.getObjectType().equalsIgnoreCase("COLUMN")) {
                Vector attributeMatrix = dbobject.getAttributeMatrix();
                if(null!=attributeMatrix) {
                    for(int i=0; i<attributeMatrix.size(); i++) {
                        Vector attributeMatrixLine = (Vector) attributeMatrix.elementAt(i);
                        if(null!=attributeMatrixLine) {
                            String currOwnerType = null;
                            String currOwnerName = null;
                            int    position = 0;
                            for(int j=0; j<attributeMatrixLine.size(); j++) {
                                DatabaseAttribute dbattribute = (DatabaseAttribute) attributeMatrixLine.elementAt(j);
                                if(dbattribute.getName().equalsIgnoreCase("_owner_type")) {
                                    currOwnerType = dbattribute.getValue();
                                }
                                if(dbattribute.getName().equalsIgnoreCase("_owner_name")) {
                                    currOwnerName = dbattribute.getValue();
                                }
                                if(dbattribute.getName().equalsIgnoreCase("_position")) {
                                    position = new Integer(dbattribute.getValue()).intValue();
                                }
                            }
                            if(   null!=currOwnerType && ownerType.equalsIgnoreCase(currOwnerType)
                               && null!=currOwnerName && ownerName.equalsIgnoreCase(currOwnerName)) {
                               String linkedName = dbobject.getLink();
                                   if(null!=linkedName) {
                                       linkedName = "<a href=\"" + linkedName + "\">"
                                           + dbobject.getObjectName() + "</a>";
                                   } else {
                                       linkedName = dbobject.getObjectName();
                                   }

                                memberColumns.put(new Integer(position), linkedName);
                            }
                            currOwnerType = null;
                            currOwnerName = null;
                        }
                        attributeMatrixLine = null;
                    }
                }
                attributeMatrix = null;
            }
        }
        it = null;

        if(memberColumns.size()>0) {
            Iterator     it2 = memberColumns.values().iterator();
            StringBuffer str = new StringBuffer();

            while(it2.hasNext()) {
                str.append(", ");
                str.append((String) it2.next());
            }
            it2 = null;
            memberColumnsString = str.toString().substring(2);
        }
        memberColumns = null;

        return memberColumnsString;
    }

    private String getInitCapString(String str) {
        if(null!=str) {
            return str.substring(0,1).toUpperCase() + str.substring(1).toLowerCase();
        } else {
            return str;
        }
    }
}
